scilla_version 0
import ListUtils IntUtils
library TokenPayment

type Error =
| AdminValidationFailed
| StagingAdminNotExist
| StagingAdminValidationFailed

let make_error =
fun (result: Error) =>
let result_code =
match result with
| AdminValidationFailed => Int32 -1
| StagingAdminNotExist => Int32 -2
| StagingAdminValidationFailed => Int32 -3
end
in
{ _exception: "Error"; code: result_code }

let one_msg =
fun (m : Message) =>
let e = Nil {Message} in
Cons {Message} m e

let addfunds_tag = "AddFunds"

let register_address_list: List ByStr20 -> List Int32 -> List Message = 
	fun(addresses: List ByStr20) => 
	fun(balances: List Int32) =>
		let init = Emp ByStr20 Int32 in 
		let zip = @list_zip ByStr20 Int32 in
    let zipped = zip addresses balances in
    let foldleft = @list_foldl (Pair ByStr20 Int32) (Map ByStr20 Int32) in
    let f = @fst ByStr20 Int32 in 
    let s = @snd ByStr20 Int32 in 
    let insert = 
      fun(acc : Map ByStr20 Int32) => 
      fun(address_credits_p : Pair ByStr20 Int32) => 
        let address = f address_credits_p in 
        let balance = s address_credits_p in 
        builtin put acc address balance
		in foldleft insert init zipped

contract TokenPayment(
    init_admin: ByStr20
)
(* Current contract admin *)
field contractadmin: ByStr20  = init_admin
(* Admin that can be claimed by existing address *)
field stagingcontractadmin: Option ByStr20 = None {ByStr20}

procedure ThrowError(err: Error)
    e = make_error err;
    throw e
end
procedure IsAdmin(initiator: ByStr20)
    contractadmin_tmp <- contractadmin;
    is_admin = builtin eq initiator contractadmin_tmp;
    match is_admin with
    | True  =>
    | False =>
        e = AdminValidationFailed;
        ThrowError e
    end
end
(* Update staged admin *)
transition UpdateAdmin(admin: ByStr20)
    IsAdmin _sender;
    staging_admin = Some {ByStr20} admin;
    stagingcontractadmin := staging_admin
end
(* Staged admin can claim the staged admin and become admin *)
transition ClaimAdmin()
    staging_admin <- stagingcontractadmin;
    match staging_admin with
    | Some admin =>
        is_valid = builtin eq _sender admin;
        match is_valid with
        | True =>
            contractadmin := admin;
            staging_admin = None {ByStr20};
            stagingcontractadmin := staging_admin;
            e = { _eventname: "ClaimAdmin"; new_admin: admin };
            event e
        | False =>
            e = StagingAdminValidationFailed;
            ThrowError e
        end
    | None =>
        e = StagingAdminNotExist;
        ThrowError e
    end
end
(* get back remaining tokens *)
transition DrainContractBalance(amt: Uint128)
    IsAdmin _sender
end
(* send payments to zrc2 compatible *)
transition Pay(addresses: List ByStr20, amts: List Uint128)
    IsAdmin _sender;
    voter_balances_ = register_address_list addresses credits; 
    voter_balances := voter_balances_; 
    e = owner_register_event_success; 
    event e
end 